#include <iostream>


void ShowINfo() { //глобальная функция 
	std::cout << "\nGearge!\n"<<std::endl;
}


namespace A { //пространсвто имен А

	namespace B { //в пространство имен А вложен пространство имен В
		
		void ShowINfo() { //локальная функция с таким же именем как у глобальной 
			std::cout << "\nWendy!\n" << std::endl; 
		}
	}
}



int main() {
	ShowINfo(); //вызываем глобальную функцию
	A::B::ShowINfo(); //вызываем локальную функцию

	::ShowINfo();//вызов глобальной функции
	::A::B::ShowINfo();//вызываем локальную функцию

	/*using namespace A::B; //директива
	ShowINfo();*/
	/*A::B::ShowINfo();*/ //вызываем  функцию с прямым доступом и путем к ней
}

//Мы использовали using namespace A::B -> это показывает,что теперь функция ShowINfo(); видна так же как и глобальная ,тепреь не нужно 
//указывать путь к этой переменной (В результате отпадает необходимость в явном указании области видимости. как сказано в T16 ),но теперь 
//выплывает другая проблема = (Перед её применением следует убедиться, что во включаемом пространстве имен отсутствуют идентификаторы, дублирующие
//идентификаторы глобального пространства. ) все параметры ,которые имели одинаковые  имена за пределами using namespace A::B будут не давать работать
//пременным с таким же именем ,так как система не поймет о чем вы говорите об этом A::B::ShowINfo(); или об ShowINfo();  .
//Нужно 
// 1.либо переименновать пременные ,
// 2.либо убрать using namespace A::B; ,
// 3.либо не убирая директиву указывать плный путь к этой переменной,но в этом случае глобальная переменная не будет работать .